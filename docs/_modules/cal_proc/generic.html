
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>cal_proc.generic &#8212; Creation/updates of nc files for FAAM calibration data 0.3 documentation</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Creation/updates of nc files for FAAM calibration data 0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cal_proc.generic</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Generic instrument class.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">datetime</span><span class="o">,</span> <span class="nn">pytz</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">netCDF4</span>

<span class="kn">import</span> <span class="nn">pdb</span>


<div class="viewcode-block" id="walk_dstree"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.walk_dstree">[docs]</a><span class="k">def</span> <span class="nf">walk_dstree</span><span class="p">(</span><span class="n">ds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recursive Dataset group generator.</span>

<span class="sd">    from: http://unidata.github.io/netcdf4-python/netCDF4/index.html#section2</span>

<span class="sd">    Args:</span>
<span class="sd">        ds (:obj:`netCDF4.Dataset`): Dataset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="k">yield</span> <span class="n">values</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">walk_dstree</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">children</span></div>


<div class="viewcode-block" id="append_time"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.append_time">[docs]</a><span class="k">def</span> <span class="nf">append_time</span><span class="p">(</span><span class="n">otime</span><span class="p">,</span><span class="n">ntime</span><span class="p">,</span><span class="n">concat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Appends time variable/s to existing time coordinate.</span>

<span class="sd">    Note that increasing the size of the ``time`` coordinate also increases the</span>
<span class="sd">    size of all of the dependent variables.</span>

<span class="sd">    Args:</span>
<span class="sd">        otime (:obj:`netCDF4.Variable`): Original Dataset time coordinate. As</span>
<span class="sd">            is coordinate dimensionality is 1d.</span>
<span class="sd">        ntime (:obj:`netCDF4.Variable` or `iterable`): New time variables to</span>
<span class="sd">            append to `otime`. May either be a netCDF4 variable or a simple</span>
<span class="sd">            iterable of values. These values may be datetime objects. If the</span>
<span class="sd">            values are strings some attempt to convert them will be done. If</span>
<span class="sd">            they are numbers then it is assumed that units and calendar are</span>
<span class="sd">            compatible with those in `otime`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A netCDF4 variable with the same units and calendar as `otime`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">dateutil</span> <span class="k">import</span> <span class="n">parser</span>

    <span class="c1"># Convert original times into datetime objects</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ocalendar</span> <span class="o">=</span> <span class="n">otime</span><span class="o">.</span><span class="n">calendar</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">ocalendar</span> <span class="o">=</span> <span class="s1">&#39;standard&#39;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">odatetime</span> <span class="o">=</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">otime</span><span class="p">[:],</span><span class="n">otime</span><span class="o">.</span><span class="n">units</span><span class="p">,</span><span class="n">ocalendar</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="c1"># num2date does not work on empty arrays</span>
        <span class="n">odatetime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ntime</span><span class="p">)</span> <span class="o">==</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Variable</span><span class="p">:</span>
        <span class="c1"># Convert new times into datetime objects</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ncalendar</span> <span class="o">=</span> <span class="n">ntime</span><span class="o">.</span><span class="n">calendar</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">ncalendar</span> <span class="o">=</span> <span class="s1">&#39;standard&#39;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ndatetime</span> <span class="o">=</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">ntime</span><span class="p">[:],</span><span class="n">ntime</span><span class="o">.</span><span class="n">units</span><span class="p">,</span><span class="n">ncalendar</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># num2date does not work on empty arrays</span>
            <span class="n">ndatetime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ntime</span><span class="p">,(</span><span class="nb">int</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">str</span><span class="p">)):</span>
            <span class="n">ntime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ntime</span><span class="p">])</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ntime</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ntime</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">,</span><span class="s1">&#39;S&#39;</span><span class="p">]):</span>
            <span class="c1"># Attempt to convert the times into a list of datetime object</span>
            <span class="c1"># Assume that all formats are the same!</span>
            <span class="n">ndatetime</span> <span class="o">=</span> <span class="p">[</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">n_</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">n_</span> <span class="ow">in</span> <span class="n">ntime</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume are numbers in same format as those in otime</span>
            <span class="n">ndatetime</span> <span class="o">=</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">ntime</span><span class="p">,</span><span class="n">otime</span><span class="o">.</span><span class="n">units</span><span class="p">,</span><span class="n">ocalendar</span><span class="p">)</span>

    <span class="n">adatetime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">odatetime</span><span class="p">,</span><span class="n">ndatetime</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="n">concat_axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">adatetime</span><span class="p">,</span><span class="n">otime</span><span class="o">.</span><span class="n">units</span><span class="p">,</span><span class="n">ocalendar</span><span class="p">)</span></div>


<div class="viewcode-block" id="Generic"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.Generic">[docs]</a><span class="k">class</span> <span class="nc">Generic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Parent class for general instrument parsing and processing.</span>

<span class="sd">    Generic forms the basis for all specific instrument processor classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            ds (:obj:`netCDF4.Dataset`): Dataset from ingested cal_nc file</span>

<span class="sd">        .. note::</span>

<span class="sd">            I don&#39;t think that this is actually true anymore...</span>

<span class="sd">            Note that cal_nc file as been read using r+. Thus variables (?)</span>
<span class="sd">            and attributes cannot be appended to. Values must be read to</span>
<span class="sd">            a python variable, the nc key deleted, then rewritten with</span>
<span class="sd">            appropriate modfications.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span>


    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Help, specifically with regards to structure of update() method if</span>
<span class="sd">        it exists. If update() does not exist then use docstr of processor</span>
<span class="sd">        class __init__()</span>

<span class="sd">        .. todo::</span>

<span class="sd">            This needs to be updated</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># To print name of instance use: type(self).__name__</span>
        <span class="kn">import</span> <span class="nn">pdb</span>

        <span class="n">h1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">h2</span> <span class="o">=</span> <span class="n">h1</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="n">h2</span> <span class="o">=</span> <span class="n">h1</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">h3</span> <span class="o">=</span> <span class="n">h2</span>  <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add__str__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="n">h3</span> <span class="o">=</span> <span class="n">h2</span>

        <span class="k">return</span> <span class="n">h3</span>


<div class="viewcode-block" id="Generic.update_ver"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.Generic.update_ver">[docs]</a>    <span class="k">def</span> <span class="nf">update_ver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Includes program version information as root attribute.</span>

<span class="sd">        Version information is determined from ``cal_proc.__init__()``.</span>
<span class="sd">        Any existing version strings shall be overwritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">cal_proc</span> <span class="k">import</span> <span class="n">__version__</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">software_version</span> <span class="o">=</span> <span class="n">__version__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">software_version</span> <span class="o">=</span> <span class="n">__version__</span></div>


<div class="viewcode-block" id="Generic.update_hist"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.Generic.update_hist">[docs]</a>    <span class="k">def</span> <span class="nf">update_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">update</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the global history attribute.</span>

<span class="sd">        The history nc attribute is a single string of comma-delineated text.</span>

<span class="sd">        Args:</span>
<span class="sd">            update (:obj:`str` or :obj:`list`): Update for history string.</span>
<span class="sd">                If None (default) then auto-generate string based on today&#39;s</span>
<span class="sd">                datetime. If given then append update/s to history attribute</span>
<span class="sd">                string. Any ``&lt;now&gt;`` or ``&lt;today&gt;`` strings are changed to</span>
<span class="sd">                today&#39;s datetime.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># With datetime v3.6 can use timespec=&#39;seconds&#39; to drop ms</span>
        <span class="c1"># Timezone aware timestamp is generated by default.</span>
        <span class="n">t_</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">microsecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">T%H%M&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">update</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
           <span class="n">update</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> Auto update&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">update</span> <span class="ow">is</span> <span class="s1">&#39;NA&#39;</span><span class="p">:</span>
            <span class="c1"># This assumes that all updates have been handled in the cdl</span>
            <span class="c1"># file. So nothing needs to be done here.</span>
            <span class="n">update</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">update</span><span class="p">,</span><span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">update</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
            <span class="c1"># If is a list of strings then join</span>
            <span class="n">update</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">update</span><span class="p">[:])</span>

        <span class="c1"># Change any shortcuts to today&#39;s date</span>
        <span class="n">update</span> <span class="o">=</span> <span class="n">update</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&lt;today&gt;&#39;</span><span class="p">,</span><span class="n">t_</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&lt;now&gt;&#39;</span><span class="p">,</span><span class="n">t_</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">hist_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">history</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># username attribute does not exist so create it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">update</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># username attribute already exists to append to end of string</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">history</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hist_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">update</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hist_</span><span class="p">,</span><span class="n">update</span><span class="p">)</span></div>


<div class="viewcode-block" id="Generic.update_user"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.Generic.update_user">[docs]</a>    <span class="k">def</span> <span class="nf">update_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">update</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the global username attribute.</span>

<span class="sd">        The username nc attribute is a single string of comma-delineated text.</span>

<span class="sd">        Args:</span>
<span class="sd">            update (:obj:`str` or :obj:`list`): Update for username string.</span>
<span class="sd">                If None (default) then auto-generate string based on previous</span>
<span class="sd">                entries in netCDF and ask user. String usually given as</span>
<span class="sd">                `username &lt;user@email&gt;`. Append username/s to existing attribute</span>
<span class="sd">                string.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract existing username from ds</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">user_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">username</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># username attribute does not exist so create it</span>
            <span class="n">user_</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">last_user_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last_user_</span> <span class="o">=</span> <span class="n">user_</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">update</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">]:</span>
            <span class="c1"># No username given so use last entry from nc if possible but</span>
            <span class="c1"># confirm with user</span>
            <span class="k">if</span> <span class="n">last_user_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">]:</span>
                <span class="k">while</span> <span class="n">update</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">]:</span>
                    <span class="n">update</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Enter &#39;username &lt;email&gt;&#39;: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">update</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Enter &#39;username &lt;email&gt;&#39; [enter for </span><span class="si">{}</span><span class="s2">]: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">last_user_</span><span class="p">))</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">update</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">update</span> <span class="o">=</span> <span class="n">last_user_</span>
        <span class="c1"># elif update is &#39;NA&#39;:</span>
        <span class="c1">#     # This assumes that all updates have been handed in the cdl</span>
        <span class="c1">#     # file. So nothing needs to be done here</span>
        <span class="c1">#     update = &#39;&#39;</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">update</span><span class="p">,</span><span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">update</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
            <span class="c1"># If is a list of strings then join</span>
            <span class="n">update</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">update</span><span class="p">[:])</span>

        <span class="k">if</span> <span class="n">user_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">update</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># username attribute already exists to append to end of string</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">user_</span><span class="p">,</span><span class="n">update</span><span class="p">)</span></div>


<div class="viewcode-block" id="Generic.update_attr"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.Generic.update_attr">[docs]</a>    <span class="k">def</span> <span class="nf">update_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attr</span><span class="p">,</span><span class="n">update</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates an attribute by appending update.</span>

<span class="sd">        Root and group attributes are generally strings and should not be</span>
<span class="sd">        changed. However they may be appended to, it is common to create a</span>
<span class="sd">        comma-delineated string. If attr does not exist then it is not</span>
<span class="sd">        created by this method. If a new attribute is required then it is</span>
<span class="sd">        more sound to create a new nc file from scratch that includes this</span>
<span class="sd">        attribute.</span>

<span class="sd">        Args:</span>
<span class="sd">            attr (:obj:`str`): Name of attribute to update. If the attribute</span>
<span class="sd">                is in a group instead of the root then the full path of</span>
<span class="sd">                the attribute must be included with / seperators. If attr</span>
<span class="sd">                does not exist within the dataset then do not create but</span>
<span class="sd">                return.</span>
<span class="sd">            update (:obj:`str` or :obj:`list`): Update for attribute.</span>
<span class="sd">                If None (default) then just return. If string then append</span>
<span class="sd">                to existing attr string with comma seperator. If list of</span>
<span class="sd">                strings then append comma-delineated string generated from</span>
<span class="sd">                list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">update</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">]:</span>
            <span class="c1"># No updates to be made</span>
            <span class="k">return</span>

        <span class="c1"># Extract existing attribute from ds</span>
        <span class="n">grp_</span><span class="p">,</span> <span class="n">attr_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">attr_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">grp_</span><span class="p">]</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">attr_</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c1"># Attribute as given does not exist so do nothing</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Attribute </span><span class="si">{}</span><span class="s1"> does not exist.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Delete existing group attribute</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">grp_</span><span class="p">]</span><span class="o">.</span><span class="n">delncattr</span><span class="p">(</span><span class="n">attr_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Delete existing root attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">delncattr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">update</span><span class="p">,</span><span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">update</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
            <span class="c1"># If is a list of strings then join</span>
            <span class="n">update</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">update</span><span class="p">[:])</span>

        <span class="c1"># Append update to existing attribute string and rewrite into ds</span>
        <span class="k">if</span> <span class="n">grp_</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">setncattr</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr_old</span><span class="p">,</span><span class="n">update</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">grp_</span><span class="p">]</span><span class="o">.</span><span class="n">setncattr</span><span class="p">(</span><span class="n">attr_</span><span class="p">,</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr_old</span><span class="p">,</span><span class="n">update</span><span class="p">))</span></div>


<div class="viewcode-block" id="Generic.change_val"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.Generic.change_val">[docs]</a>    <span class="k">def</span> <span class="nf">change_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">var</span><span class="p">,</span><span class="n">old_val</span><span class="p">,</span><span class="n">new_val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Changes a single variable/attribute value.</span>

<span class="sd">        The variable or attribute name must be given along with the old</span>
<span class="sd">        value, ``old_val``, that is to be change to ``new_val``. If ``old_val``</span>
<span class="sd">        is not found then nothing is done.</span>

<span class="sd">        .. todo::</span>

<span class="sd">            Not implemented</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span></div>


    <span class="k">def</span> <span class="nf">_add_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds extra values to end of an unlimited coordinate.</span>

<span class="sd">        If a coordinate is increased in size then all of the variables that</span>
<span class="sd">        depend on that coordinate are increased to the same size along the</span>
<span class="sd">        unlimited dimension. This internal method should usually be followed by</span>
<span class="sd">        ``_add_var()``.</span>

<span class="sd">        Args:</span>
<span class="sd">            coord (:obj:`str`): string of path/name of coordinate variable. This</span>
<span class="sd">                can be found with</span>
<span class="sd">                ``os.path.join(self.ds[coord].group().path,self.ds[coord].name)``</span>
<span class="sd">            vals (`iterable`): Iterable of values to append to the end of</span>
<span class="sd">                ``self.ds[coord]``. Type must match the dtype of the coordinate</span>
<span class="sd">                variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that is unlimited coordinate</span>
        <span class="c1"># Annoyingly have to split path and variable name</span>
        <span class="n">cpath</span><span class="p">,</span><span class="n">cname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cpath</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;/&#39;</span><span class="p">]:</span>
            <span class="n">unlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span><span class="o">.</span><span class="n">isunlimited</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">cpath</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">cname</span><span class="p">]</span><span class="o">.</span><span class="n">isunlimited</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">unlim</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Either the variable name passed is not a coordinate (ie the</span>
            <span class="c1"># variable name and dimension are the same and 1d) or the</span>
            <span class="c1"># coordinate is not unlimited and thus cannot be extended.</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not an unlimited coordinate&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Ensure vals is an array and preserve any masking</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">coord</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">append_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">coord</span><span class="p">],</span><span class="n">vals</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

        <span class="k">return</span> <span class="mi">0</span>


    <span class="k">def</span> <span class="nf">_parent_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">unlim</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns paths/dimensions of given variable even if in parent group.</span>

<span class="sd">        var is full path to the variable name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Names of found dimensions that match those of var</span>
        <span class="n">fnd_dims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fnd_unlim</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">_path</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">fnd_dims</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="c1"># Walk up through groups attempting to find required dimensions</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">_path</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span>
                         <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c1"># Step up to parent group</span>
                <span class="k">break</span>
                <span class="n">_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">dimensions</span>
                         <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">]</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">_unlim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">_path</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">isunlimited</span><span class="p">()</span>
                          <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_dims</span><span class="p">]</span>

            <span class="n">fnd_dims</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_path</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_dims</span><span class="p">])</span>
            <span class="n">fnd_unlim</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_unlim</span><span class="p">)</span>
            <span class="n">_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fnd_dims</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="n">fnd_dims</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">dimensions</span>
                             <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">])</span>
            <span class="n">fnd_unlim</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">isunlimited</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_dims</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">unlim</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fnd_dims</span><span class="p">)[</span><span class="n">fnd_unlim</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">unlim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">,</span><span class="s1">&#39;idx&#39;</span><span class="p">]:</span>
            <span class="c1"># Return an index list of unlimited/fixed dimensions</span>
            <span class="k">return</span> <span class="n">fnd_unlim</span>
        <span class="k">elif</span> <span class="n">unlim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">fnd_dims</span><span class="p">,</span> <span class="n">fnd_unlim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fnd_dims</span>


    <span class="k">def</span> <span class="nf">_add_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds extra values to end of an already extended variable.</span>

<span class="sd">        If a coordinate is increased in size then all of the variables that</span>
<span class="sd">        depend on that coordinate are increased to the same size along the</span>
<span class="sd">        unlimited dimension. If the variable holds numbers then these extra</span>
<span class="sd">        values are masked. If the variable holds strings then they are just</span>
<span class="sd">        empty strings and there is no masking. This method writes the new</span>
<span class="sd">        values in vals into these new array positions of var. If the</span>
<span class="sd">        number of values is &gt; number of new elements at the end of the</span>
<span class="sd">        array then it is assumed that there is an error and no action is taken.</span>

<span class="sd">        Args:</span>
<span class="sd">            var (:obj:`str`): string of path/name of variable. This</span>
<span class="sd">                can be found with</span>
<span class="sd">                ``os.path.join(self.ds[var].group().path,self.ds[var].name)``</span>
<span class="sd">            vals (`iterable`): Iterable of values to append to the end of</span>
<span class="sd">            ``self.ds[var]``. Type must match the dtype of the variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure vals is an array and preserve any masking</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Assume that only a single element in the unlimited dimension</span>
            <span class="c1"># has been given in vals. Increase number of dimension to match var</span>
            <span class="c1"># This assures (?) that 0 axis is the unlimited one...</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">vals</span><span class="p">[::],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">vals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> \
               <span class="s1">&#39;Mismatch in number of dimensions&#39;</span>

        <span class="c1"># Annoyingly have to split path and variable name</span>
        <span class="n">vpath</span><span class="p">,</span><span class="n">vname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

        <span class="c1"># Find unlimited dimension/s for this var</span>
        <span class="c1">#print(var)</span>
        <span class="n">dims</span><span class="p">,</span> <span class="n">unlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_dim</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unlim</span> <span class="ow">is</span> <span class="p">[]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Variable </span><span class="si">{}</span><span class="s1"> does not have unlimited dimension&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="c1"># Create slice to write to the correct dimension</span>
        <span class="c1"># That is the last elements of the unlimited dimension</span>
        <span class="n">unlim_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unlim</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unlim_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># There is more than one unlimited dimension. This is allows in nc4</span>
            <span class="c1"># Currently there is no code to automatically determine which</span>
            <span class="c1"># dimension val should be added to. Therefore ask user for clarity,</span>
            <span class="c1"># this is a bit rubbish so maybe _add_var() should have an</span>
            <span class="c1"># additional arg for the dimension to extend??</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">More than one UNLIMITED dimension found for variable: &#39;</span> <span class="o">+</span>
                  <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
            <span class="n">req_unlim_idx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="n">req_unlim_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_i</span><span class="p">,</span><span class="n">_d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dims</span><span class="p">)[</span><span class="n">unlim_idx</span><span class="p">]):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_i</span><span class="p">,</span> <span class="n">_d</span><span class="p">))</span>
                <span class="n">req_unlim_idx</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Enter number of dimension to use [0]: &#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">req_unlim_idx</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">req_unlim_idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">req_unlim_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_i</span><span class="p">):</span>
                    <span class="n">req_unlim_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">req_unlim_idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">req_unlim_idx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">unlim_idx</span> <span class="o">=</span> <span class="n">unlim_idx</span><span class="p">[</span><span class="n">req_unlim_idx</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Adding </span><span class="si">{}</span><span class="s1"> to dimension: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="n">dims</span><span class="p">[</span><span class="n">unlim_idx</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unlim_idx</span> <span class="o">=</span> <span class="n">unlim_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># &#39;empty&#39; slots filled from first position towards array end,</span>
            <span class="c1"># thus the -1*len(vals)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is not as easy as one might think!</span>
            <span class="k">assert</span> <span class="n">unlim_idx</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="c1"># The lines below assume that the unlimited dimension that is</span>
            <span class="c1"># being extended is the 0th. The other indexers are set to write</span>
            <span class="c1"># only to as many elements in each dimension as required (those</span>
            <span class="c1"># outside this range remain masked). This is to cope with ragged</span>
            <span class="c1"># arrays.</span>
            <span class="c1"># However, it is likely/possible that this shall not always be the</span>
            <span class="c1"># case. I have not been able to test this case yet, thus the assert</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">idx</span><span class="p">[</span><span class="n">unlim_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1">#idx[1] = range(len(vals[0]))</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="ow">and</span> \
           <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="c1"># Strings are vlen arrays which have more limited access</span>
            <span class="c1"># Need to write each individual string seperately (?)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># Use string format to convert (also converts None)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">any</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())):</span>
            <span class="c1"># Assume that all other types of variables are masked</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Variable: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
                <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Insufficient empty space in </span><span class="si">{}</span><span class="s1">!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>


<div class="viewcode-block" id="Generic.append_var"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.Generic.append_var">[docs]</a>    <span class="k">def</span> <span class="nf">append_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">var</span><span class="p">,</span><span class="n">coord_vals</span><span class="p">,</span><span class="n">var_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to append to an existing netCDF4 variable and associated coord</span>

<span class="sd">        .. todo::</span>

<span class="sd">            Redundant/not currently used.</span>

<span class="sd">        The extra coordinate values are appended to the coordinate of vname</span>
<span class="sd">        in self. This automatically creates the same number of masked entries</span>
<span class="sd">        in all of the variables that depend on that coordinate.</span>

<span class="sd">        :param var: String of path/name of variable. This can be found with</span>
<span class="sd">            ``os.path.join(self.ds[var].group().path,self.ds[var].name)``</span>
<span class="sd">        :type var: String</span>
<span class="sd">        :param coord_vals: Iterable of values to append to the end of unlimited</span>
<span class="sd">            coordinate of variable var.</span>
<span class="sd">        :type coord_vals: List or array</span>
<span class="sd">        :param var_vals: Iterable of values to append to the end of var. Must</span>
<span class="sd">            be the same length as coord_vals in the unlimited dimension.</span>
<span class="sd">        :type var_vals: List or array</span>

<span class="sd">        .. note::</span>

<span class="sd">            This is a bit complicated/not sensible. It is possible/probable</span>
<span class="sd">            to add a variable (along with the coord) then append to a different</span>
<span class="sd">            variable that uses the same coordinate which then writes the same</span>
<span class="sd">            coordinate values into the coordinate again.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

        <span class="c1"># # Find unlimited dimension of variable</span>
        <span class="c1"># for i,dim_ in enumerate(var.dimensions):</span>
        <span class="c1">#     if var.isunlimited():</span>
        <span class="c1">#         break</span>

        <span class="c1"># if type(nvar) == netCDF4.Variable:</span>
        <span class="c1">#     # Extract values out of variable</span>
        <span class="c1">#     nvars = nvar[:]</span>
        <span class="c1"># elif isinstance(nvar,(int,float,str)):</span>
        <span class="c1">#     # Ensure that new variables is a list if not a netCDF4 variable</span>
        <span class="c1">#     nvars = [nvar]</span>

        <span class="c1"># if ovar.dtype == str:</span>
        <span class="c1">#     avar = ovar.rstrip(&#39;,&#39;) + &#39;,&#39;.join(nvars)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     avar = np.ma.concatenate((ovar[:],nvars), axis=i)</span>


<div class="viewcode-block" id="Generic.append_dict"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.Generic.append_dict">[docs]</a>    <span class="k">def</span> <span class="nf">append_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">var_d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Appends multiple variables with a single coordinate.</span>

<span class="sd">        Multiple variable values that use the same coordinate can be appended</span>
<span class="sd">        to existing dataset variables in one go. Variables that do not already</span>
<span class="sd">        exist in the dataset are ignored. Use add instead...</span>

<span class="sd">        Args</span>
<span class="sd">            var_d (:obj:`dict`): Dictionary of multiple variable values to be</span>
<span class="sd">                appended. Dictionary keys are the variable path+name strings</span>
<span class="sd">                and the dictionary values are either a netCDF variable or a</span>
<span class="sd">                sub-dictionary of values and attributes</span>

<span class="sd">        .. todo::</span>

<span class="sd">            Currently does not accept netCDF4 variable values.</span>
<span class="sd">            Currently only accepts iterable of data.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            var_d = {coord: netCDF4.Variable,</span>
<span class="sd">                     var1:  [1,2,3,4,5],</span>
<span class="sd">                     var2:  {&#39;_data&#39;: [1,2,3,4,5],</span>
<span class="sd">                             &#39;var2_attr1&#39;: &#39;var2 attribute 1&#39;,</span>
<span class="sd">                             &#39;var2_attr1&#39;: &#39;var2 attribute 1&#39;, ...}</span>
<span class="sd">                     var3:  &#39;Fred&#39;}</span>

<span class="sd">        Note that all variables should be the same length if they are</span>
<span class="sd">        list-like. Any variables not the same length as the maximum length</span>
<span class="sd">        variable will be broadcast so that they are longer. This could well</span>
<span class="sd">        have unintended concequences however it does mean that variables that</span>
<span class="sd">        are the same thing repeated for all coordinate values (eg var3)</span>
<span class="sd">        will be replicated automatically.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            This is not done yet!</span>

<span class="sd">        There is nothing special about the coordinate variable, the function</span>
<span class="sd">        identifies the coordinate as being the variable with the same name</span>
<span class="sd">        as its dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find coordinate variable</span>
        <span class="n">coord_d</span>  <span class="o">=</span> <span class="p">{}</span>
        <span class="n">var_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var_d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">k_</span> <span class="ow">in</span> <span class="n">var_keys</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">k_</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">k_</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># Coordinates can only have one dimension, thus the [0]</span>
                    <span class="c1"># Coordinates cannot use a parent group dimension</span>
                    <span class="n">coord_d</span><span class="p">[</span><span class="n">k_</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c1"># Variable does not exist in dataset so remove from var_d</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">var_d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k_</span><span class="p">,</span><span class="n">v_</span> <span class="ow">in</span> <span class="n">coord_d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_coord</span><span class="p">(</span><span class="n">k_</span><span class="p">,</span><span class="n">v_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">k_</span><span class="p">,</span><span class="n">v_</span> <span class="ow">in</span> <span class="n">var_d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_var</span><span class="p">(</span><span class="n">k_</span><span class="p">,</span><span class="n">v_</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Variable: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k_</span><span class="p">))</span>
                <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="Generic.append_dataset"><a class="viewcode-back" href="../../_source/cal_proc.html#cal_proc.generic.Generic.append_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">append_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="p">,</span>
                       <span class="n">force_append</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">,</span><span class="s1">&#39;history&#39;</span><span class="p">],</span>
                       <span class="n">exclude</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Adds groups, attributes, dimensions, and variables from ds.</span>

<span class="sd">        Attributes of ``self.ds`` shall take priority over those of the same</span>
<span class="sd">        name in `ds`, such attribute values of `ds` shall be ignored. The</span>
<span class="sd">        exception is if the attribute key is included in ``force_append``. In</span>
<span class="sd">        this case the resultant attribute shall be a comma-delineated</span>
<span class="sd">        combination string of the individual attributes with that from ``ds``</span>
<span class="sd">        being appended to that of ``self.ds``.</span>

<span class="sd">        Variables from ``ds`` are appended to the same variable in ``self``. The</span>
<span class="sd">        variables are sorted by the unlimited dimension. Variables only in</span>
<span class="sd">        ds shall be added to ``self``.</span>

<span class="sd">        Any groups, attributes, or variables in ``ds`` that are not to be</span>
<span class="sd">        added or appended can be specified as a list with `exclude`.</span>

<span class="sd">        Args:</span>
<span class="sd">            ds (:obj:`netCDF4.Dataset`) netCDF Dataset to add into ``self.ds``</span>
<span class="sd">            force_append (:obj:`list`): List of any root or group attribute</span>
<span class="sd">                strings that should always be appended to, even if they are</span>
<span class="sd">                identical. Default is [&#39;username&#39;,&#39;history&#39;]. Group attribule</span>
<span class="sd">                strings must include full path.</span>
<span class="sd">            exclude (:obj:`list`): List of attribute or variable name strings</span>
<span class="sd">                (but not variable attributes) that are not to be added or</span>
<span class="sd">                appended to.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">append_group</span><span class="p">(</span><span class="n">mgrp</span><span class="p">,</span><span class="n">ngrp</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Updates master ds group with values from new ds group.</span>

<span class="sd">            Either input may be a dataset, in which case the root group is</span>
<span class="sd">            operated on, or a group/subgroup within the dataset. This function</span>
<span class="sd">            does not walk down through any subsequent groups.</span>

<span class="sd">            Args:</span>
<span class="sd">                mgrp (:obj:`netCDF4.Dataset`): Master dataset object which may</span>
<span class="sd">                    be root or a group.</span>
<span class="sd">                ngrp (:obj:`netCDF4.Dataset`): Dataset object the contents of</span>
<span class="sd">                    which shall be added or appended to those in the master</span>
<span class="sd">                    dataset object.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Add any new attributes, ignore any conflicts, string append any others</span>
            <span class="n">new_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k_</span><span class="p">:</span><span class="n">v_</span> <span class="k">for</span> <span class="p">(</span><span class="n">k_</span><span class="p">,</span><span class="n">v_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ngrp</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> \
                         <span class="k">if</span> <span class="n">k_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()}</span>
            <span class="n">app_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k_</span><span class="p">:</span><span class="n">v_</span> <span class="k">for</span> <span class="p">(</span><span class="n">k_</span><span class="p">,</span><span class="n">v_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ngrp</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> \
                         <span class="k">if</span> <span class="p">(</span><span class="n">k_</span> <span class="ow">in</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()</span> <span class="ow">and</span> <span class="n">v_</span> <span class="o">!=</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span> <span class="ow">and</span> <span class="n">k_</span> <span class="ow">in</span> <span class="n">force_append</span><span class="p">)}</span>

            <span class="n">mgrp</span><span class="o">.</span><span class="n">setncatts</span><span class="p">(</span><span class="n">new_attrs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k_</span><span class="p">,</span><span class="n">v_</span> <span class="ow">in</span> <span class="n">app_attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">app_attr</span> <span class="o">=</span> <span class="n">ngrp</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">app_attr</span> <span class="o">=</span>  <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">mgrp</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">k_</span><span class="p">)[::],</span>
                                           <span class="n">ngrp</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">k_</span><span class="p">)])</span>
                <span class="n">mgrp</span><span class="o">.</span><span class="n">setncattr_string</span><span class="p">(</span><span class="n">k_</span><span class="p">,</span><span class="n">app_attr</span><span class="p">)</span>

            <span class="c1"># Add any new dimensions</span>
            <span class="n">new_dim</span> <span class="o">=</span> <span class="p">{</span><span class="n">d_</span><span class="p">:</span><span class="n">v_</span> <span class="k">for</span> <span class="p">(</span><span class="n">d_</span><span class="p">,</span><span class="n">v_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ngrp</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">d_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">dimensions</span><span class="p">}</span>
            <span class="n">mgrp</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_dim</span><span class="p">)</span>

            <span class="c1"># Add any new variables</span>
            <span class="n">new_var</span> <span class="o">=</span> <span class="p">{</span><span class="n">n_</span><span class="p">:</span><span class="n">v_</span> <span class="k">for</span> <span class="p">(</span><span class="n">n_</span><span class="p">,</span><span class="n">v_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ngrp</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> \
                       <span class="k">if</span> <span class="n">n_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">}</span>
            <span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>

            <span class="c1"># Concatenate any variables along the unlimited dimension</span>
            <span class="c1"># that exist in master already. Do this in two steps as operating</span>
            <span class="c1"># directly on the dataset coordinate/s affects the dependent</span>
            <span class="c1"># variables immediately.</span>
            <span class="c1"># Note that new/changed variable attributes are not added.</span>

            <span class="k">for</span> <span class="n">n_</span> <span class="ow">in</span> <span class="n">ngrp</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">ngrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">][:],</span>
                                      <span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">][:])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error with array_equal&#39;</span><span class="p">)</span>
                    <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

            <span class="n">app_var</span> <span class="o">=</span> <span class="p">{</span><span class="n">n_</span><span class="p">:</span><span class="n">v_</span> <span class="k">for</span> <span class="p">(</span><span class="n">n_</span><span class="p">,</span><span class="n">v_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ngrp</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> \
                       <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">n_</span> <span class="ow">in</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
                               <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">ngrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">][:],</span>
                                                  <span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">][:])])}</span>

            <span class="n">mod_var</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">n_</span><span class="p">,</span><span class="n">v_</span> <span class="ow">in</span> <span class="n">app_var</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># Find unlimited dimension</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">d_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">d_</span><span class="p">]</span><span class="o">.</span><span class="n">isunlimited</span><span class="p">():</span>
                        <span class="k">break</span>

                <span class="c1"># Convert datetime stamps to datetime then back again ensuring</span>
                <span class="c1"># units are those of the master group.</span>
                <span class="c1"># Determine if timestamp with variable name and units that</span>
                <span class="c1"># include &#39;since&#39;. A bit flakey but hopefully ok.</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="n">n_</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                        <span class="s1">&#39;units&#39;</span> <span class="ow">in</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">]</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()])</span> \
                   <span class="ow">and</span> <span class="s1">&#39;since&#39;</span> <span class="ow">in</span> <span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">]</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>

                    <span class="n">mod_var</span><span class="p">[</span><span class="n">n_</span><span class="p">]</span> <span class="o">=</span> <span class="n">append_time</span><span class="p">(</span><span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">],</span>
                                              <span class="n">ngrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>

    <span class="c1">### TODO: Use pint to make sure any units in variables are comparable</span>
    <span class="c1">###       and convert new variables to those used in master</span>

                    <span class="n">mod_var</span><span class="p">[</span><span class="n">n_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">][:],</span>
                                                     <span class="n">ngrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">][:]),</span>
                                                    <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># Write modified variables back into master</span>
            <span class="k">for</span> <span class="n">n_</span><span class="p">,</span><span class="n">v_</span> <span class="ow">in</span> <span class="n">mod_var</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">mgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">n_</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">v_</span>


        <span class="c1"># Determine path strings to all (sub-)groups in both datasets</span>
        <span class="n">mgrps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">grps</span> <span class="ow">in</span> <span class="n">walk_dstree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">):</span>
            <span class="n">mgrps</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">g_</span><span class="o">.</span><span class="n">path</span> <span class="k">for</span> <span class="n">g_</span> <span class="ow">in</span> <span class="n">grps</span><span class="p">])</span>

        <span class="n">ngrps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">grps</span> <span class="ow">in</span> <span class="n">walk_dstree</span><span class="p">(</span><span class="n">ds</span><span class="p">):</span>
            <span class="n">ngrps</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">g_</span><span class="o">.</span><span class="n">path</span> <span class="k">for</span> <span class="n">g_</span> <span class="ow">in</span> <span class="n">grps</span><span class="p">])</span>

        <span class="c1"># Determine groups that are in the new dataset that are not in the master</span>
        <span class="c1"># Create an equivalent empty group in the master, group will be filled</span>
        <span class="c1"># by calling append_dsgroup(). Sort list by length of string so</span>
        <span class="c1"># create upper level groups before any sub-groups.</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ngrps</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">mgrps</span><span class="p">),</span><span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span>

        <span class="c1"># Copy any new root attributes, dimensions, and/or variables to master</span>
        <span class="n">append_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span><span class="n">ds</span><span class="p">)</span>

        <span class="c1"># Do the same for all groups and sub-groups</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">ngrps</span><span class="p">:</span>
            <span class="n">append_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">grp</span><span class="p">],</span><span class="n">ds</span><span class="p">[</span><span class="n">grp</span><span class="p">])</span></div></div>



</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Creation/updates of nc files for FAAM calibration data 0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, FAAM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>